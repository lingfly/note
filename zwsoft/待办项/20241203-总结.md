

## 技术栈

1. springboot
2. mybatis
3. mysql
4. redis
5. rabbitmq
6. docker
7. kryo
8. antlr


## 业务

1. 生命周期管理系统
2. 大体量保存优化
3. 文档保存使用sqlite缓存
4. 模型加载使用redis缓存
5. 日常业务设计和开发
6. 服务的部署
7. mysql入库性能测试

## 问题

1. 服务非堆内存爆涨
2. 使用字节流文件上传接口，且会经过日志过滤器，导致oom

## 产品生命周期管理系统

### 项目背景

为满足高端制造行业的大体量设计需求，公司决定研发一个采用C/S架构的高端三维CAD图形平台（此前公司产品皆为单机应用），生命周期管理系统是这个平台的后端服务，负责建模数据的保存、共享和复用。

### 主要模块

1. 对象定义管理：包括对象类型、关系、路径依赖、用户、角色等。
2. 对象的生命周期原子操作：使用对象定义进行创建、更新、修改所有者、变更状态、锁定、版本管理等操作。
3. 文件管理：通过一个文件网关对接不同文件服务，支持本地文件服务和公有云部署时的oss文件存储。
4. 权限管理：对不同类型对象、不同状态进行版本控制，并用antlr4实现通过表达式进行权限控制。
5. 自定义触发器：每个生命周期的原子操作都可以绑定一个或多个触发器，这个触发器是一段可以由用户自定义的java代码，绑定后在原子操作前后执行。
6. c++内核：上层业务由java实现，底层内核有java和c++两个版本，使用c++内核时java通过jni调用c++内核。

### 本人主要负责的内容 

1. 大体量模型保存：模型数据是业务对象的组合，只是体量庞大，json文件达到几十M至几个G不等，原子操作不能满足性能需求，所以把模型保存分离为三层完成批量处理，分别是数据校验、生命周期操作和批量入库。（因为触发器内客户写的代码也会调用原子操作，并且一个对象操作可能依赖前一个对象触发器的结果，所以没办法通过另外写一套批量操作来实现，这里是把对象操作分成了原子操作和批量保存两种模式，拿一个简单的重命名操作举例来说，执行顺序是权限校验、前置触发器、重命名、后置触发器、入库，在批量保存模式里最后一步就不是入库，而是保存到一个内存数据结构里面给后面的操作使用。到这里就会发现，既然对象没入库，而且触发器内调用的原子操作可能会用到，所以在批量模式下，所有的对象查询就要查询内存和数据库的并集）
2. 模型加载：同样出于性能的考量，批量加载模型的业务对象。从数据库得到业务对象后，使用redis缓存对象，用对象的更新时间判断redis缓存是否过时。缓存到redis后，通过一个后台任务使用redis管道批量设置过期时间。
3. 模型保存的性能优化：尽管保存的流程是批量执行的，但由于体量实在太大，光是入库时间就难以接受。为了优化入库时间，并且在模型保存已经分层处理的前提下，可以认为经过了前两个阶段（数据校验、生命周期操作）之后的数据必然是可以入库的，所以把入库部分剥离出来由后台任务执行。引入sqlite保存完成了前两个阶段的模型数据作为模型缓存，提供给客户端加载模型使用。该方案优化了70%客户端模型保存时间。（为了让sqlite缓存在集群内共享，这里写入sqlite文件后是关闭连接把文件上传到文件服务，这是一个待优化点）
4. 模型保存的任务队列：引入了sqlite模型缓存之后，意味着用户可以在模型数据还没有入库就可以加载缓存模型从而进行增量更新操作。为了避免这个问题，设计了任务队列，使得同一个模型的保存操作按照时间排队。
5. 模型剪枝算法：模型数据结构是一个有向有环图，且边可以作为边的端点。模型和模型之间存在嵌套关系，当做模型版本升级/复制/删除/缓存等操作时，需要得到仅被当前模型引用而没有被其他模型引用的子对象，为此使用双重的dfs染色法实现在模型结构内剔除的指定分支，该算法在百万级数据情况下5秒左右得出结果。（对象经过一个关系连接另一个对象，关系也可以通过一个关系连接另一个关系或对象，难点在于删除一个节点后怎么断掉指向该节点的边，）
6. 服务部署：服务使用docker部署，使用java后端+shell脚本+vue前端实现服务部署功能，支持指定分支打包镜像、指定环境部署服务以及服务初始化和服务更新。


## 问题

1. 对于大体量对象，jvm使用什么垃圾收集器
2. 对于oom，排查思路，排除工具，内存堆栈dump命令
3. 介绍项目


### 介绍项目

 现在市面上大多数协同建模都是文件级别的协同，也就是后端只能管理整个模型，无法深入建模细节，导致模型的增量更新和版本管理对整个模型文件进行操作，
 比如说增量更新只能由新模型覆盖旧模型，新建版本只能复制一个模型副本出来。

 我们的系统精细到可以对模型的每一个对象进行管理，但是这又引入了另一个问题，因为模型文件达到几百兆的量级是很常见的情况，这个时候模型有几十万对象，
 对后端服务的性能有很大的挑战。


### 垃圾收集算法

1. 标记-清除
2. 
