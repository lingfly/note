### 加载
在加载阶段，虚拟机需要完成3件事情：
1. 通过一个类的全限定名来获取定义此类的二进制流
2. 将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的数据访问入口

对于一个非数组类的加载，开发人员可以自定义类加载器去控制类字节流的获取方式

而数组类由虚拟机直接生成，但是数组类的元素类型要靠类加载器去加载

### 验证
目的是验证字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全

#### 文件格式验证
验证字节流是否符合Class文件的规范，以及是否能被当前版本的虚拟机处理

可能包括以下验证点：
* 是否以魔术0xCAFEBABE开头
* 主，次版本号是否在当前虚拟机处理范围内
* 常量池中的常量是否有不被支持的常量类型

#### 元数据验证
对字节流所描述的信息进行语义校验，确保不存在不符合Java语言规范的元数据信息

可能包括以下验证点：
* 这个类是否有父类
* 这个类是否继承了不被继承的类
* 如果这个类不是抽象类，那它是否实现了父类和接口所要求的全部方法

#### 字节码验证
通过数据流和控制流确定程序语义是合法的，符合逻辑的

可能包括以下验证点：
* 保证任意时刻操作数栈的数据类型和指令序列能配合工作
* 保证跳转指令不会跳转到方法体以外的字节码指令上
* 保证方法体中的类型转换是有效的

#### 符号引用验证
这一验证在解析阶段中发生，确保解析动作能正常执行

可能包括以下验证点：
* 符号引用通过字符串描述的全限定名是否能找到对应的类

### 准备
正式为类变量分配内存并设置初始值

不过这个阶段进行内存分配的仅包括类变量（static修饰的变量）

这里设置的初始值指的是默认零值

常量（final修饰的变量）会被赋值为程序指定的值

### 解析
虚拟机将常量池中的符号引用替换为直接引用的过程

### 初始化
初始化是类加载的最后一步，到这一步才开始执行类中定义的Java代码，可以通过程序去初始化变量和其他资源

初始化阶段是执行类构造器clinit方法的过程

clinit方法是编译器自动收集类中所有赋值动作和静态代码块合并而成的

编译器收集的顺序是由源代码中出现的顺序决定的，静态代码块只能访问到出现在代码块之前的变量；定义在它之后的变量只能赋值，不能访问。

虚拟机保证在子类的clinit方法执行之前，父类的clinit方法已经被执行。