### hashmap结构

hashmap的主干是是一个entry数组，一个entry就是一个键值对

当要添加一个键值对时，根据key计算出hash值，以确定插入数组的位置

当出现冲突时，使用拉链法形成一张链表，将hash值相同的放进同一张链表

如果链表的长度大于8，就会把链表转化为红黑树

### put方法

1. 先判断数组是否为空或长度为0，如果是就扩容
2. 然后根据键值key计算hash值得出数组索引
3. 如果没有冲突就直接插入数组
4. 有冲突就遍历链表插入(如果是红黑树直接对树进行插入)
5. 如果链表长度大于8，就转换为红黑树

![put](\resources\hashmap_put.png)

### 求元素的数组下标

```java
i = (n - 1) & hash

static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

hashcode方法返回的值是32位的，而数组大小不可能有那么大，所以对h进行了移位异或运算，能够利用到每一位的信息，减少冲突的概率。

n-1和hash与运算的这一步，相当于取模运算，因为n为2的m幂次，减一之后低m位全为1，与hash相与，就相当于选取hash低m作为数组下标。

### resize方法

扩容时机

* 初始化时
* 键值对数大于阈值时
* 转化为红黑树时
* 使用putAll方法时


