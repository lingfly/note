### InnoDB表级锁和行级锁共存
InnoDB行级锁是通过给索引上的索引项加锁来实现的，只有通过索引检索数据才使用行级锁，否则使用表级锁

### 锁类型
1. 共享锁(share)：允许事务读取一行数据
2. 排他锁(exclusive)：允许事务更新或删除一行数据
3. 意向共享锁：事务获取一行数据的共享锁前，必须先获取该表的意向共享锁
4. 意向排他锁：事务获取一行数据的排他锁前，必须先获取该表的意向排他锁

如果一个事务请求的类型与当前锁类型兼容，InnoDB就授予该事务请求的锁，否则事务阻塞到锁释放
![锁兼容关系](\resources\锁兼容.png)

意向锁是由InnoDB引擎自动加的，不受程序控制

#### 意向锁的作用：
当表级锁和行级锁共存时，意向锁可以降低锁检测的开销

一个表上持有意向共享锁时，意味着此时表中某些行持有共享锁，
当某个操作申请这个表的排他锁时，不用逐行检测是否持有行级锁，而是直接检测该表是否持有意向锁，大大提高了检测锁的效率

### 一致性的非锁定读
InnoDB存储引擎通过多版本并发控制(MVCC)的方式读取当前时间数据库中行的数据，读取操作不会等待行上的锁释放，而是读取一个行的快照数据

InnoDB在read committed和repeatable read隔离级别下使用一致性的非锁定读，不过对快照的定义不同

1. read committed隔离级别下总是读取最新的一份快照数据
2. repeatable read隔离级别会读取事务开始时的快照数据

### 外键和锁

对外键执行插入和更新操作时，会查询父表(外键所引用的表)中的行数据，如果外键没有创建索引，这时就会对父表进行全表扫描(使用S锁)，如果父表已经加了X锁就会造成死锁

InnoDB默认为外键创建索引

### 锁算法
1. record lock：当个行记录上的锁
2. gap lock：锁住一个范围，但不包括记录本身
3. Net-key lock：锁住一个范围，并且包括记录本身

InnoDB默认使用Net-Key Lock，可以防止幻读