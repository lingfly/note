### 桶排序
先建立n个桶，利用散列函数将要排序的序列散列到各个桶中，
且第i个桶的所有值要比第i+1个桶的值要小，
然后对每个桶的元素进行排序，最后将所有桶连接起来，完成排序。

桶排序不稳定，要想排序效率高，就要求散列函数要尽可能的将序列元素均匀的分散在各个桶中

对桶数n的要求，极限情况下每个桶中只有一个元素，即n=序列长度。当然，桶数越大，占用内存就越大。

### 计数排序
假定原数组长度为n，大小范围为k=max-min；
先用count数组统计原数组中各个值的出现次数，
统计完后count[i]表示数值i的出现次数；

再计算使用count数组计算小于等于i的元素个数，
此时，count[i]表示小于等于i的元素个数；


最后将各个元素的最终位置记录在rank数组；
对于原数组元素a[i],它在排序后的位置应是--count[a[i]]，
(除去自己，且每记录完一个值count计数减1)，比如count[1]=1表示小于等于1的数有1个，而这个就是自己，原数组索引从0开始，所以要减1；

最后将rank数组复制到原数组排序完毕。

java代码
```java
//针对c数组的大小，优化过的计数排序
publicclassCountSort{
    public static void main(String[] args){
      //排序的数组
        int a[]={100,93,97,92,96,99,92,89,93,97,90,94,92,95};
        int b[]=countSort(a);
        for(inti:b){
           System.out.print(i+"");
        }
        System.out.println();
    }
    public static int[] countSort(int[]a){
        int b[] = new int[a.length];
        int max = a[0],min = a[0];
        for(int i:a){
            if(i>max){
                max=i;
            }
            if(i<min){
                min=i;
            }
        }//这里k的大小是要排序的数组中，元素大小的极值差+1
        int k=max-min+1;
        int c[]=new int[k];
        for(int i=0;i<a.length;++i){
            c[a[i]-min]+=1;//优化过的地方，减小了数组c的大小
        }
        for(int i=1;i<c.length;++i){
            c[i]=c[i]+c[i-1];
        }
        for(int i=a.length-1;i>=0;--i){
            b[--c[a[i]-min]]=a[i];//按存取的方式取出c的元素
        }
    return b;
    }
}
```


### 基数排序

基数排序和计数排序有些类似，计数排序是统计元素出现次数，要用到的桶数为元素大小范围，基数排序是按元素的每一位数（个位，十位，百位...）统计，只需要10个桶

先将序列按照个位数大小使用计数排序，排序完后复制到原数组，再对十位数进行排序，以此类推，直到排完所有位。

### 总结

+ 这三种都不是比较排序，复杂度不受O(nlogn)限制
+ 计数排序和基数排序只适用于整数
+ 桶排序不稳定，计数和基数排序稳定