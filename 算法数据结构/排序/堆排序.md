### 堆排序

堆就是一颗完全二叉树，并且(大顶堆)堆中任一节点的值总是大于其子节点的值

堆可以用数组来表示，比如使用1为根节点(不用0位置)，则节点i的左子节点为2*i，右子节点为2*i+1；i节点的父亲节点为i/2

如果以0为根节点，则节点i的左子节点为2*i+1，右子节点为2*i+2；i节点的父亲节点为(i-1)/2

特点：

+ 稳定，效率与序列初始位置无关
+ 一次操作能决定一个元素的最终位置

#### 构建堆

堆排序的第一步是将要排序的数组构建为一个堆

从右到左进行下沉操作，如果一个节点的子节点已是堆有序，那执行下沉之后以这个节点为根的子树也是堆有序

叶子节点不需要下沉，所以只需要对一半的节点执行下沉操作

#### 下沉操作：

1. 比较节点i的两个子节点，选出较大的子节点
2. 比较节点i与较大的子节点
3. 如果子节点大于节点i，则交换位置
4. 更新i的位置为子节点位置，继续下沉

```java
void sink(int[] nums,int i,int N){
    int child;
    for(;2*i+1<N;i=child){
        child=2*i+1;
        if(child!=N-1&&nums[child+1]>nums[child]){
            child++;
        }
        if(nums[i]<nums[child]){
            swap(nums,i,child);
        }
    }
}
```

#### 堆排序：

堆排序就是将堆顶元素删除然后放在堆的最后一个位置(这个位置是由于删除一个元素而空出来的)

执行N次deleteMax则将数组从小到大排序完毕

1. 将跟节点与最后一个节点交换
2. 节点数减一(删除一个节点)
3. 对根节点下沉

```java
void sort(int[] nums,int left,int right){
    int N=nums.length;
    //构建堆
    for(int i=N/2;i>=0;i--){
        sink(nums,i,N);
    }
    //堆排序
    for(int i=0;i<nums.length;i++){
        swap(nums,0,N-1);
        N--;
        sink(nums,0,N);
    }
}
```