

### pom文件添加依赖
```xml
<!-- 服务相关包 -->
<!-- 如果在sc不引入此依赖，在sc将应用服务器的服务注册到客户端时，会因为类的缺失而导致服务注册结果不符合预期，最终在服务调用时出错 -->
<dependency>
	<groupId>org.tinygroup</groupId>
	<artifactId>org.tinygroup.serviceprocessor</artifactId>
	<version>${tiny_version}</version>
</dependency>
<!-- web相关依赖 -->
<dependency>
	<groupId>org.tinygroup</groupId>
	<artifactId>org.tinygroup.serviceweblayer</artifactId>
	<version>${tiny_version}</version>
</dependency>
<!-- 远程服务相关依赖 -->
<dependency>
	<groupId>org.tinygroup</groupId>
	<artifactId>org.tinygroup.cepcoremutiremoteimpl</artifactId>
	<version>${tiny_version}</version>
</dependency>
```

#### 相关报错
当SC服务器的cepcoremutiremoteimpl版本与应用服务器不兼容时，有如下报错
```xml
java.io.IOException: 远程主机强迫关闭了一个现有的连接。
	at sun.nio.ch.SocketDispatcher.read0(Native Method)
	at sun.nio.ch.SocketDispatcher.read(SocketDispatcher.java:43)
	at sun.nio.ch.IOUtil.readIntoNativeBuffer(IOUtil.java:223)
	at sun.nio.ch.IOUtil.read(IOUtil.java:192)
	at sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:380)
	at io.netty.buffer.UnpooledUnsafeDirectByteBuf.setBytes(UnpooledUnsafeDirectByteBuf.java:447)
	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:881)
	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:241)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:119)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:511)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:468)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:382)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:354)
	at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:111)
	at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:137)
	at java.lang.Thread.run(Thread.java:748)
WARN  - ScHandler                  - 占位符个数[1]和参数个数[2]不匹配.
```
### SC服务器(注册中心)
#### Application.springbeans.xml配置

以下配置为支持服务中心的最小配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">

	<bean id="sc" scope="singleton"
		class="org.tinygroup.cepcoremutiremoteimpl.sc.ScOperator">
        <!-- sc服务器对外提供的注册端口 -->
		<property name="port" value="9191"></property>
	</bean>
</beans>

```

#### application.xml配置

以下配置为支持服务中心的最小配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<application>
	<application-processors>
		<application-processor bean="cepCoreProcessor"></application-processor>
	</application-processors>
	
	<!-- node-name为应用对外的节点名称，在一个集群中，该名称需要唯一 -->
	<cep-configuration node-name="nodeServer">
		<!-- operator name对应Application.springbeans.xml中NodeOperator的beanId -->
		<operator name="node"></operator>
		<!-- sc服务中心的ip和port值，其中port为sc服务器中配置的port值 -->
		<scs>
			<sc host="127.0.0.1" port="9191"></sc>
		</scs>
	</cep-configuration>
</application>
```

### 应用服务器

#### application.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<application>
	<application-processors>
		<application-processor bean="fileResolverProcessor"></application-processor>
		<application-processor bean="serviceApplicationProcessor"></application-processor>
		<application-processor bean="cepCoreProcessor"></application-processor>
	</application-processors>
	
	<!-- node-name为应用对外的节点名称，在一个集群中，该名称需要唯一 -->
	<cep-configuration node-name="nodeServer">
		<!-- operator name对应Application.springbeans.xml中NodeOperator的beanId -->
		<operator name="node"></operator>
		<!-- sc服务中心的ip和port值，其中port为sc服务器中配置的port值 -->
		<scs>
			<sc host="127.0.0.1" port="9191"></sc>
		</scs>
	</cep-configuration>
</application>
```

#### Application.springbeans.xml配置
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd">


	<bean id="fileResolver" scope="singleton"
		class="org.tinygroup.fileresolver.impl.FileResolverImpl">
		<property name="fileProcessorList">
			<list>
				<ref bean="i18nFileProcessor" />
				<ref bean="xStreamFileProcessor" />
				<ref bean="xmlServiceFileProcessor" />
			</list>
		</property>
	</bean>
	<bean id="fileResolverProcessor" scope="singleton"
		class="org.tinygroup.fileresolver.applicationprocessor.FileResolverProcessor">
		<property name="fileResolver" ref="fileResolver"></property>
	</bean>
	
	<bean id="node" scope="singleton"
		class="org.tinygroup.cepcoremutiremoteimpl.node.NodeOperator">
		<!-- 客户端所在机器的ip地址 -->
		<property name="localHost" value="127.0.0.1"></property>
		<!-- 客户端在sc集群中的端口（此端口并非对外的访问端口，而是sc集群中用于各服务器之间通讯的端口） -->
		<property name="localPort" value="8181"></property>
		<!-- 应用比重 -->
		<property name="weight" value="20"></property>
	</bean>
</beans>
```

### 远程调用

1. 获取CEPCore实例对象

直接通过bean容器获取
```java
package com.hundsun.tbsp.node.a;

import org.springframework.stereotype.Component;
import org.tinygroup.beancontainer.BeanContainerFactory;
import org.tinygroup.cepcore.CEPCore;
@Component
public class BizOperator {
    CEPCore core;
    public CEPCore getCore() {
        if (core == null) {
            core = BeanContainerFactory.getBeanContainer(
                    this.getClass().getClassLoader()).getBean(
                    CEPCore.CEP_CORE_BEAN);
        }
        return core;
    }
}

```

2. 在应用服务器设置服务方法映射

* service-component：
    type为服务接口类型，bean为实现类

* service-method：
    local-name为本地方法名，service-id即为第3步中创建Event所传递的参数

* service-parameters：方法参数类型映射

* service-result：方法返回值类型映射

```xml
<service-components>
  <service-component type="com.hundsun.tbsp.node.b.inter.NodeBService" bean="nodeBServiceImpl">
    <service-method local-name="echoFromB" service-id="com.hundsun.tbsp.node.b.inter.NodeBService.echoFromB" method-name="echoFromB" cacheable="false" category="com.hundsun.tbsp.node.b.inter.NodeBService">
      <service-parameters>
        <service-parameter name="req" type="java.lang.String" required="false" is-array="false"/>
      </service-parameters>
      <service-result name="resp" required="false" is-array="false" type="java.lang.String"/>
    </service-method>
  </service-component>
</service-components>
```


3. 指定执行节点进行Tiny服务调用
```java

@Controller
@RequestMapping(value="/nodeA")
public class NodeAController {
    @Autowired
    private BizOperator bizOperator;

    @ResponseBody
    @RequestMapping(value="/test")
    public String test(@ServiceParameter String name) {
        //org.tinygroup.context.Context
        Context context = ContextFactory.getContext();

        context.put("req", name);//此处的key为服务发布方发布出来的服务的参数name值

//         org.tinygroup.event.Event
        Event event = Event.createEvent("com.hundsun.tbsp.node.b.inter.NodeBService.echoFromB", context);
        event.getServiceRequest().setNodeName("nodeServer");  //写法1：直接指定node-name，此种方式，需要保证网内节点名不重复
        //event.getServiceRequest().setNodeName("127.0.0.1:9191:nodeServer");  //写法2：指定完整的节点信息 ip:port:node-name
        bizOperator.getCore().process(event); // 此处的CEPCore对象就是前面获取的，实际调用中，建议由框架统一封装这个方法，有开发者去掉用这个封装
        //服务的返回值为resp,真实类型为String
        String result = event.getServiceRequest().getContext().get("resp");
        return result;
    }
}
```

### 调用成功

1. 应用服务器注册

![注册成功](/resources/注册成功.png)

2. sc服务器响应

![sc注册响应](/resources/sc注册响应.png)

3. 成功调用

![调用成功](/resources/调用成功.png)